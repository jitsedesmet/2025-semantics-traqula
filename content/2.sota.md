## Related work
{:#related-work}

<!--
<span class="comment" data-author="RT">If you have space for it, I also recommend adding a related work section. Maybe you can find some SPARQL parsing-related research papers. For example, Yasqui has a paper, which should probably be cited. SPARQL.js is also an important one, not sure if it has a paper. Comunica could be discussed briefly as well. And then there are the different SPARQL parsers in existence, which could be mentioned, such as Jena, Oxigraph, ... A detailed survey is not necessary though, we can keep this for the next paper. But a high-level overview may be good to have.</span>
-->

<!--
related work:

YASGUI as a visualiser.
Jena parser: uses javaCC, a builder toolkit kind-off. https://javacc.github.io/javacc/
-> Strength of TRAQULA is the fact that it's using java classes, you cannot break an interface, you cannot 'extent' aka start from a parser, and remove components.

Oxigraph: Seems to use https://github.com/kevinmehall/rust-peg -> https://github.com/oxigraph/oxigraph/blob/2247319a1ff9132fd574d56db40f7178da938000/lib/spargebra/src/parser.rs#L778
does not seem to have modularity build in.


-->

In this section we investigate the various SPARQL parser currently used.
Comunica and YASGUI currently use [SPARQL.JS](https://www.npmjs.com/package/sparqljs) as parser.
Sparql.JS is a parser created using the [Jison](https://www.npmjs.com/package/jison) parser builder.
Jison uses a DSL heavily inspired on EBNF.

<!-- Proof: https://github.com/apache/jena/blob/3b6fb69d4ef78f4f130235a8fccb853291ea2b47/jena-arq/src/main/java/org/apache/jena/sparql/lang/sparql_10/SPARQLParser10.java -->
[Apache Jana](https://jena.apache.org/) uses [JavaCC](https://javacc.github.io/javacc/) to construct its parser.
Again reacquiring a compile-step.


<!-- Proof: https://github.com/oxigraph/oxigraph/blob/2247319a1ff9132fd574d56db40f7178da938000/lib/spargebra/src/parser.rs#L778 -->
[Oxigraph](https://github.com/oxigraph/oxigraph) uses [rust-peg](https://github.com/kevinmehall/rust-peg)
again reacquiring a compile-step to get the compiler parser.
Interestingly, since rust is a compiled language with a strong macro system,
the EBNF based DSL can be included within the source file itself and the parser be constructed during the compilation of the larger project.
The library does however not seem to support modular definitions.

<!--
Proof on Chevrotain: https://github.com/stardog-union/millan/blob/fc0c04b1818d20c68cf7fceb41f6ba0ee8258bd5/src/sparql/BaseSparqlParser.ts
-->
Stardog uses their own [Stardog Millan](https://github.com/stardog-union/millan) which uses [Chevrotain](cite:cites chevrotain).
They use the classic object-oriented definition using Chevrotain, and  I don't seem to find where they create the AST.
The object-oriented approach has the explicit problem that you cannot easily change contracts since there is no loose coupling between types and implementation.
This loose coupling sounds bad at first but provides the benefit that a parser can change a dependent rule without altering the original rule's implementation.
This also prohibits a parser from being constructed based on an existing parser but removing grammar rules.
These findings thereby limit the modularity of the parser. 


<!--
Proof: https://github.com/openlink/virtuoso-opensource/blob/23cff6731d6f8f431bde314453ec07038cc62bf5/README.GIT.md#package-dependencies
-->
[Virtuoso](https://virtuoso.openlinksw.com/) likely uses the [Bison](https://www.gnu.org/software/bison/) parser generator since it is listed in the project dependencies.

<!--
proof: https://github.com/blazegraph/database/blob/829ce8241ec29fddf7c893f431b57c8cf4221baf/sparql-grammar/src/main/java/com/bigdata/rdf/sail/sparql/ast/sparql.jj
-->
[Blazegraph](https://github.com/blazegraph/database/) also uses [JavaCC].

Ontotext GraphDB uses YASGUI as a UI, and their engine uses


