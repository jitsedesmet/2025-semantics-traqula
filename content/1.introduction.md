## Introduction
{:#introduction}

The [SPARQL query language](cite:cites spec:sparql), a cornerstone of the Semantic Web stack,
has evolved through both standardisation and real-world innovation.
While SPARQL 1.1 defines a clear and extensible foundation,
the ecosystem has gradually diverged as implementers introduced powerful but engine-specific extensions.
For example, Virtuoso offers [full-text search capabilities](cite:cites virtuoso-full-text-search)
Apache Jena supports [CONSTRUCT QUAD queries](cite:cites jena-construct-quad),
and Oxigraph provides [extended date-time-functionality including the ADJUST function](cite:cites oxigraph-adjust).
These features are often highly valuable, but also incompatible,
creating a heterogeneous landscape where queries that run on one engine may fail on another.

This diversity presents a serious challenge for SPARQL portability, SPARQL tooling and federated querying.
With the finalisation of the [SPARQL 1.2 specification](cite:cites sparql-1-2),
the gap between supported language features is likely to widen further,
since migration to SPARQL 1.2 is not trivial, requiring substantial updates to the underlying [datasets representation and RDF store](cite:cites rdf-1-2).
Moreover, the working group has announced that after SPARQL 1.2 finalisation,
they plan to move toward a more agile ["maintenance and new features" mode](https://github.com/w3c/sparql-dev/issues/32#issuecomment-2621209920),
which hints at even faster iteration cycles in the future.
As a result, there is a growing need for tooling that embraces extensibility and modularity by design.

In this work, we present Traqula,
a modular SPARQL parser and generator built on top of the [Chevrotain parser toolkit](cite:cites chevrotain).
Traqula is developed within the [Comunica ecosystem](cite:cites comunica),
known for its flexible and modular architecture.
Unlike traditional parser generators such as [ANTLR](cite:cites parr1995antlr) or [Bison](cite:cites bison-gnu),
which rely on Domain Specific Languages (DSLs) and generate static parsing code — Traqula defines parsers entirely within TypeScript.
This eliminates the compile step, enables programmatic extension, and leverages strong typing to provide a safer,
more developer-friendly API.
Traqula is not a hand-built parser either since it uses the declarative rule constructors provided by Chevrotain.

By adopting the Builder design pattern, Traqula empowers both researchers and practitioners to add, override, or swap grammar fragments at runtime.
This opens the door to use cases such as maintainable heterogeneous query interface tooling (e.g., for tools like [YASGUI](https://yasgui.org/)),
SPARQL version translation, and rapid experimentation with new language features.
In an ecosystem where SPARQL flavors are growing rather than converging,
we believe modularity is not just a nicety—it’s a necessity.

<!--

## homebrew

TODO: what even is a parser? And a generator? What is an AST?

The SPARQL query language knows many flavors.
SPARQL flavors are typically [SPARQL 1.1 spec](cite:cites spec:sparql) compliant, and add additional functionality ontop of it.
Examples include [full text search in Vituoso](https://docs.openlinksw.com/virtuoso/sparqlextensions/#rdfsparqlrulefulltext),
[Apache Jena's Construct quad](https://jena.apache.org/documentation/query/construct-quad.html#Grammar) and [Oxigraph's Adjust function](https://github.com/oxigraph/oxigraph/wiki/SPARQL#sep-0002-calendar-and-duration-operations).

OXIGRAPH at 02/01/2023 (DD/MM/YYYY) https://github.com/oxigraph/oxigraph/pull/336
JENA at 01/12/2022 https://github.com/apache/jena/pull/1631

All of these extension have merit, but create a heterogeneous ecosystem as queries supported by one query engine,
might not be supported by another.
The [Comuncica](https://comunica.dev/) organisation, believes in flexible, modular software.
As can be seen by the main product of the organisation, the Comunica query engine, used by both academics and industry alike.
Academics benefit from the modularity as it allows them to test groundbreaking techniques with ease.
Meanwhile, industry loves the heterogeneity as it allows them to tailor the software to their specific needs.
As such, there are different default builds of Comunica,
ranging a minimal built to run in a browser, to big builds tackling the heterogeneity of query sources.
A hurdle within this heterogeneity has been the modularity the parser.
A parser is a software component that takes a string input and generates some datastructures, often an Abstract Syntax Tree (AST). 
Parsers can be constructed in various methods, and the most prevalent ways are:
1. a hand-built parser - execution times very on the implementation. Has potential to be very fast as language specific choices can be made.
2. using a parser generator (eg. [ANTLR4](https://www.antlr.org/), [Bison](https://www.gnu.org/software/bison/)) - creates an executable parser based on some specific format. The parsers are 'compiled' from some Domain Specific Language (DSL), which is typically Extended Backus–Naur form (EBNF) based.

The first option is typically hard to make both performant and modular since language specific optimisations need to be known by all developers wanting to extend the parser.
The second choice features a compile step which makes modularity also a problem since extensions require a change in both the generator specific description and the actual parsing code.

Luckily, there is a third option, namely a Parser Building Toolkit.
This is toolkit within your preferred programming language that allows you to declare a parser within the programming language itself. 
Within the TypeScript programming language, there exists the amazing [Chevrotain Toolkit](https://chevrotain.io/docs/).
Parsers created through this toolkit are on part, if not faster than the other approaches [ref](https://chevrotain.io/performance/).

To allow for a modular SPARQL parser, we created [Traqula](https://github.com/comunica/traqula),
a modular parser and generator currently focussed on SPARQL.
Traqula at it's core wraps around Chevrotain while creating a type safe API around Chevrotain that promotes modularity through the Builder design pattern.

A modular parser would thus be advantageous to overcome these flavor discrepancies in UI tools such as [YASGUI](https://yasgui.org/).


With the finalisation of the [SPARQL 1.2 working group](https://www.w3.org/groups/wg/rdf-star/),
most of the existing SPARQL parsers will be updated to be [SPARQL 1.2](https://www.w3.org/TR/sparql12-query/) compliant,
requiring a huge community effort.
What's more, when the working group is done, it will transition to a [_maintenance and new features mode_](https://github.com/w3c/sparql-dev/issues/32#issuecomment-2621209920) that will allow for swift iteration in versions.
It is highly likely that not every data provider will perform this migration,
since a migration to SPARQL 1.2 will require a migration of your RDF store, which is quite invasive.
As such, feredated queriies over SPARQL endpoints using different versions will require translation mechanism to componsate for version discrepancies.
To create such a parser, a modular parser and generator will prove useful.

-->