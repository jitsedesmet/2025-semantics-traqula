## Introduction
{:#introduction}

TODO: what even is a parser? And a generator? What is an AST?

The SPARQL query language knows many flavors.
SPARQL flavors are typically [SPARQL 1.1 spec](cite:cites spec:sparql) compliant, and add additional functionality ontop of it.
Examples include [full text search in Vituoso](https://docs.openlinksw.com/virtuoso/sparqlextensions/#rdfsparqlrulefulltext),
[Apache Jena's Construct quad](https://jena.apache.org/documentation/query/construct-quad.html#Grammar) and [Oxigraph's Adjust function](https://github.com/oxigraph/oxigraph/wiki/SPARQL#sep-0002-calendar-and-duration-operations).
<!-- Who was first for LATERAL?
OXIGRAPH at 02/01/2023 (DD/MM/YYYY) https://github.com/oxigraph/oxigraph/pull/336
JENA at 01/12/2022 https://github.com/apache/jena/pull/1631
-->
All of these extension have merit, but create a heterogeneous ecosystem as queries supported by one query engine,
might not be supported by another.
The [Comuncica](https://comunica.dev/) organisation, believes in flexible, modular software.
As can be seen by the main product of the organisation, the Comunica query engine, used by both academics and industry alike.
Academics benefit from the modularity as it allows them to test groundbreaking techniques with ease.
Meanwhile, industry loves the heterogeneity as it allows them to tailor the software to their specific needs.
As such, there are different default builds of Comunica,
ranging a minimal built to run in a browser, to big builds tackling the heterogeneity of query sources.
A hurdle within this heterogeneity has been the modularity the parser.
Parsers can be constructed in various methods, and most prevelent ways are:
1. a hand-built parser - execution times very on the implementation. Has potential to be very fast as language specific choices can be made.
2. using a parser generator (eg. [ANTLR4](https://www.antlr.org/), [Bison](https://www.gnu.org/software/bison/)) - creates an executable parser based on some specific format. The parsers are 'compiled' from some domain specific language (DSL), which is typically Extended Backusâ€“Naur form (EBNF) based.

The first option is typically hard to make both performant and modular since language specific optimisations need to be known by all wanting to extend the parser.
The second choice features a compile step which makes modularity also a problem since extensions require a change in both the generator specific description and the actual parsing code.

Luckily, there is a third option, namely a Parser Building Toolkit.
This is toolkit within your preferred programming language that allows you to declare a parser within the programming language itself. 
Within the TypeScript programming language, there exists the amazing [Chevrotain Toolkit](https://chevrotain.io/docs/).
Parsers created through this toolkit are on part, if not faster than the other approaches [ref](https://chevrotain.io/performance/).

To allow for a modular SPARQL parser, we created Traqula, a modular parser and generator currently focussed on SPARQL.
Traqula at it's core wraps around Chevrotain while creating an API around Chevrotain that promotes modularity through the Builder design pattern.


With the finalisation of the [SPARQL 1.2 working group](https://www.w3.org/groups/wg/rdf-star/),
most of the existing SPARQL parser will be updated to be [SPARQL 1.2](https://www.w3.org/TR/sparql12-query/) compliant,
requiring a huge community effort.





