## Software Architecture
{:#architecture}

Parsers are typically implemented in one of three ways:

1. Hand-built parsers — These are manually implemented parsers tailored to a specific grammar.
While they can be highly performant due to low-level optimizations and language-specific design,
they are often difficult to maintain, extend, or modularize. 
2. Parser generators — Tools such as [ANTLR](cite:cites parr1995antlr) and [Bison](cite:cites bison-gnu) use a Domain Specific Language (DSL),
typically based on Extended Backus–Naur Form (EBNF), to define a grammar.
These grammars are then compiled into standalone parser code.
While powerful, such approaches introduce a compile step and tend to be rigid, making modular extensions cumbersome. 
3. Parser building toolkits — Libraries such as [Chevrotain](cite:cites chevrotain) offer a hybrid approach,
enabling declarative grammar specification within a host programming language.
These toolkits eliminate the compile step and allow for flexible,
programmatic grammar definitions with fine-grained control over behavior and integration.

To support modularity while keeping the mental model approachable, Traqula is built using a parser building toolkit.
Parsing itself is typically divided into multiple phases [](cite:cites alfred2007compilers),
of which the following are relevant to this work:

1. Lexical Analysis (scanning): A lexer transforms a character stream into a token stream. 
2. Syntax Analysis (parsing): A parser transforms the token stream into an abstract syntax tree (AST). 
3. Semantic Analysis: Performed during or after parsing,
this phase validates constraints not enforced by grammar alone.
For instance, SPARQL forbids binding to a variable which is already in scope.


Traqula performs some semantic checks during parsing to generate precise and contextual error messages while token positions are still available,
enabling accurate diagnostics with row and column offsets.

The Traqula codebase follows a [monorepo](https://monorepo.tools/) structure and is divided into two main categories of packages:

1. Engines — These are prebuilt, ready-to-use components such as SPARQL 1.1 and 1.2 parsers or generators. 
2. Non-engine packages — These expose modular building blocks used to construct engines,
such as grammar fragments or core construction utilities.

At the core of Traqula lies its builder infrastructure.
Each main component—lexer, parser, and generator—has a dedicated builder:
LexerBuilder, ParserBuilder, and GeneratorBuilder.
These builders provide type-safe APIs to assemble, customize, and extend parsing pipelines.

## Lexer Builder

Lexers are constructed using the LexerBuilder,
which operates on an ordered list of token definitions.
Token definitions are applied in sequence: the first match at the current position in the character stream is emitted as a token.
This makes the order of definitions critical—more specific patterns must appear before more general ones.
For example, a token defined by the regex `/appel/` should precede one defined by `/a[a-z]*/` to ensure correct tokenization.

Tokens can be defined using standard JavaScript regular expressions and annotated with optional metadata as shown in [](#token-def).
The LexerBuilder supports utility functions such as `merge`, `moveBefore`, and `moveAfter` to assist with reordering and composing token lists.
Additionally, the builders type system will help with the construction of the lexer.

<figure id="token-def" class="listing">
````/code/tokenDefinition.ts````
<figcaption markdown="block">
Definition of a token matching 'traqula' in a case-insensitive manner.
</figcaption>
</figure>

## Parser Builder

Parsers are defined using the ParserBuilder,
which allows rules to be registered by name into a rule map, thereby creating a loose coupling between registered rules.
Each rule is defined as a `ParserRule` object, containing both a rule name and a rule implementation.
Rule implementations are expressed declaratively using Chevrotain’s grammar definition functions:

1. SUBRULE: invokes another rule, registered under some name in the current parser,
2. MANY: matches zero or more occurrences of a pattern,
3. OR: matches one of several alternatives.

Additionally, rules have access to a WeakMap-based cache for optimizing repeat invocations
— useful when rule implementation construct large arrays that can be cached between executions.

Each rule implementation returns a function that,
when invoked, receives the parsing context and any parameters, and outputs part of the final syntax tree. 
[](#ruleDef) shows an example parser rule definition.

The ParserBuilder supports compositional construction and extension through methods like addRule, deleteRule, merge, and typePatch.
The typePatch utility enables type updates to existing rules
— particularly useful when extending or modifying a dependent rule without altering the original rule’s implementation.
After the construction of your parser, you can build it, as shown in [](#parserBuild),
returning a parser which allows you to start parsing a string from any of the parser rules added to the builder.

<figure id="ruleDef" class="listing">
````/code/ruleDef.ts````
<figcaption markdown="block">
The definition of a parser rule parsing either a URI of the nil token, returning the parser URI or null respectively.
</figcaption>
</figure>


<figure id="parserBuild" class="listing">
````/code/parserBuild.ts````
<figcaption markdown="block">
The construction of a parser including the iriOrNil rule constructed in [](#ruleDef).
It also shows how to parse using the iriOrNil rule as the starting rule.
</figcaption>
</figure>


## Generator Builder

Generators are used to convert an AST back into a string representation.
Like parsers, generators are composed of named rules, each associated with a definition function.
These functions receive declarative utilities for constructing the output,
and return a callable function that operates over AST nodes, context, and parameters.

This builder pattern allows for easy composition and reuse of output logic,
and promotes consistency between parsing and generation pipelines.
